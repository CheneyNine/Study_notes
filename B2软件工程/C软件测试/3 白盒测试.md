
# 图论
## 图的定义
节点：有限、非空的节点集合
边
初始节点、终止节点...

***单个节点也算图***；图可以有多个初始节点、终止节点；***但边集合不能是无限的***

路径：一个节点序列，节点与节点之间必须要有边
长度：内部边的数量
Test Path: 一个从初始节点开始到终止节点结束的路径
# 图覆盖准则
用有限空间找出可靠的有限子集，获取可靠的测试结果

## 可达性 reach
- 语法可达Syntactic reach : A path exists in the graph
- 语义可达 Semantic reach : A test exists that can execute that path
现实中会存在语法可达但是语义不可达的内容，这是多余的。

### 覆盖
图覆盖
结构覆盖：仅在顶点和边的图形上定义、源代码、需求说明、设计图
数据流覆盖：要求在图形中标注变量引用


### 测试标准
测试要求 (TR) ： 描述测试路径的属性
测试标准 ： 定义测试要求的规则
满足：  给定标准 C 的测试要求集 TR，当且仅当 TR 中的每一个测试要求，path(T) 中都有一个测试路径满足测试要求 tr 时，测试集 T 在图上满足标准 C。


## 结构化覆盖 （CPC 完全路径覆盖）

### 点覆盖（VC）
当且仅当对于 V 中每个语法上可到达的顶点 v，path(T) 中有一条路径 p 能覆盖 v 时，测试集 T 满足图 G 的顶点覆盖率要求。
TR 包含 G 中的每个可到达顶点。

### 边覆盖（EC）
当且仅当对于 E 中每一条语法上可到达的边 e，path(T) 中都有一条路径 p，使得 p 覆盖了 e 时，测试集 T 才满足图 G 的边覆盖。
TR 包含 G 中的每条可达边。
### 覆盖多条边
边对覆盖：要求覆盖边对
边对覆盖 (EPC)：TR 包含 G 中长度至多为2的每条可达路径。

### nPC
n=0->VC
n=1->EC
n=2->Edge-Pair Coverage
n=∞->Complete Path Coverage (CPC)
![[Pasted image 20240507215505.png]]

>[!note]
>对于同一个输入，同一个程序，每次执行的 test path 不一定是相同的，当程序涉及到并发执行、外部环境依赖（如文件读写、网络通信）或者随机性时，每次运行的状态结果是不一样的
>
>最简单的，有随机数生成，随机数不一样，根据判断条件，走了执行路径也会不一样。
## 包含
C1 包含 C2，记为 C1≧ C2 :对于任意 T，如果 T 满足 C1，则意味着 T 满足 C2。
C1≧ C2 并不意味着满足 C1 的 T1 可以检测到满足 C2 的 T2 检测到的任何故障。
包含仅仅意味着发现 bug 的概率更高，但发现 bug 需要恰好踩到那个点上

# 控制流图及其覆盖
代码覆盖率
- 控制流覆盖率
	语句覆盖率 
	分支覆盖率 
	路径覆盖率
覆盖率收集工具: EclEmma

## 控制流图
通常把程序抽象成图 CFG：control flow graph
节点覆盖率：执行每一条语句 
边缘覆盖：执行每个分支

几种语句的控制流图，要绘画！

```c++
if (x < y)
{
   y = 0;
   x = x + 1;
}
else
{
   x = y;
}


if (x < y)
{
   y = 0;
   x = x + 1;
}


if (x < y)
{
   return;
}
print (x);
return;


x = 0;
while (x < y)
{
   y = f (x, y);
   x = x + 1;
}


x = 0;
do
{
   y = f (x, y);
   x = x + 1;
} while (x < y);
println (y)

for (x = 0; x < y; x++)
{
   y = f (x, y);
}


x = 0;
while (x < y)
{
   y = f (x, y);
   if (y == 0)
   {
      break;
   } else if y < 0)
   {
      y = y*2;
      continue;
   }
   x = x + 1;
}
print (y);


read ( c) ;
switch ( c )
{
   case ‘N’:
      y = 25;
      break;
   case ‘Y’:
      y = 50;
      break;
   default:
      y = 0;
      break;
}
print (y);

```

![[Pasted image 20240507224151.png|425]]![[Pasted image 20240507224158.png|400]]![[Pasted image 20240507224527.png|400]]


这两句话解释了不同级别的覆盖率之间的关系。

1. **Branch coverage strictly subsumes statement coverage**:
   - 这意味着分支覆盖严格包含语句覆盖。如果你达到了100%的分支覆盖率，那么你也会自动获得100%的语句覆盖率。这是因为分支覆盖要求每个条件语句的每个分支都被至少执行一次。而每个分支都至少包含一条语句，因此分支覆盖率的达成确保了每个语句都至少被执行一次。

2. **Path coverage strictly subsumes branch coverage**:
   - 这意味着路径覆盖严格包含分支覆盖。如果你达到了100%的路径覆盖率，那么你也会自动获得100%的分支覆盖率。路径覆盖要求测试覆盖软件中的每一条可能路径，而每一条可能的路径都包含通过各种条件语句的所有可能分支组合。因此，达到100%的路径覆盖率确保了所有的分支都被覆盖，从而实现了100%的分支覆盖率。

但是不会只用path-coverage,对于现实世界的程序来说，路径覆盖可能是不可行的

### CFG-based	Coverage有效性
大约65%的所有错误可以在单元测试中发现。
单元测试主要由控制流测试方法主导。
语句和分支测试主导控制流测试。
### CFG-based	Coverage限制
100% coverage of some aspect is never a guarantee of bug-free software

## 覆盖收集：机制
源代码被插装（源代码/二进制文件）
将写入跟踪文件的日志代码插入到每个分支、语句等中。
当插装代码被执行时，覆盖信息将被写入跟踪文件。

# PPC 主路径覆盖
对于包含循环的程序，完全路径覆盖是不可能的

## 简单路径
简单路径：从节点 ni 到节点 nj 的路径是简单路径，条件是除了第一个和最后一个节点可能相同外，没有节点出现超过一次。
无内部循环
循环本身就是一条简单路径
![[Pasted image 20240508143755.png|450]]

## 主路径
不作为任何其他简单路径的子路径出现的简单路径->“最大”的简单路径
![[Pasted image 20240508144217.png|475]]
- **主路径覆盖**（Prime Path Coverage, PPC）：一个简单且有限的覆盖标准，要求同时执行和跳过循环。PPC覆盖所有长度从0开始的路径，包括节点和边覆盖，但不包括每个顶点自身循环的边路径覆盖（EPC）。

## 往返路径
以同一节点为起点和终点的***主要路径***
***SRTC CRTC***
- **简单往返路径：** 对于G中所有可达的，且可以作为往返路径起点和终点的节点，TR包含至少一条往返路径。  
- **完全往返路径：** 对于G中所有可达的节点，TR包含所有的往返路径  
- 如果一个图有自环的话，完全路径覆盖是无用的，因为这会产生无穷的路径，因而产生无穷的测试需求
- 这些标准不包括非往返路径中的节点和边，他不包含边对、边、节点覆盖

![[Pasted image 20240508152533.png]]


Are some prime paths infeasible?
由于程序的逻辑限制或条件约束，某些路径虽然在控制流图中存在，但在实际情况下无法触发。


# 基本路径覆盖
## 基本路径测试
介于分支覆盖率和全路径覆盖率之间的测试标准
满足分支测试要求的测试，同时也测试所有可用于构建计算机程序任意路径的独立路径。
## 独立路径
只有当系统中的某条路径***包含了其他路径没有包含的顶点或边***时，这条路径才独立于其他路径。
### 线性独立路径
![[Pasted image 20240508162249.png]]
线性独立路径的数量就是该矩阵的秩。
该矩阵的秩正是图的循环复杂度。

## MaCabe 计算公式
Cyclomatic Complexity 环形复杂度：确保每个语句都执行一次的***上界***
CC=E-V+2

>[!bug] 注意
>有多个终点的时候该怎么计算?
>V(G)=E−N+1
>收尾相连后计算，上面的公式就是通式；或者看分支节点数，仅限于二分支节点，CC=n+1
>https://blog.csdn.net/weixin_42398588/article/details/105622950




### 步骤
生成控制流图
计算循环复杂度
选择一组基本路径
生成基本路径测试

# 数据流覆盖
确保正确计算和使用值
## 概念
- Def：变量值存储的地方
- Use：访问变量值的地方
- def 中的值至少要满足一种、某些或所有可能的用途
- Def & Use 的集合：
- def (n) 或 def (e) ： 由节点 n 或边 e 定义的变量集合 
- use (n) 或 use (e) ： 节点 n 或边 e 使用的变量集合
- DU Pair：一对位置信息，（li，lj），变量 v 在 li 处定义，在 lj 处使用
- Def-Claer：如果从 li 到 lj ***路径中***的任何节点或边都没有给变量 v 赋值，则从 li 到 lj 的路径对变量 v 是Def-Claer（定义清晰的）
- 可达：如果从 li 到 lj 有一条关于 v 并且 Def-Claer的路径，则 v 在 li 处的定义到达了在 lj 处的用途
- DU 路径：从 v 的def到 v 的use中的子路径，并关于v是 def-clear 的
- du (ni, nj, v) the set of du-paths from ni to nj
- du (ni, v) the set of du-paths that start at ni


### 数据流覆盖的准则
ADC：所有定义覆盖
对于每一个 du-path 的集合S，TR 都包含至少 S 中的一条路径
AUC：所有使用覆盖
对于每一个du-path 的集合S，TR 都包含至少 S 中的一条路径
ADUPC：所有 DU 路径覆盖
对于每一个du-path 的集合S，TR 都包含至少 S 中的一条路径

三者中 S 的定义不同
![[Pasted image 20240508191058.png]]
# 强弱准则关系图
待完善！！！
![[Pasted image 20240508194606.png]]


# 事件流图

![[Pasted image 20240508194915.png]]

![[Pasted image 20240508194856.png]]

![[Pasted image 20240508195113.png]]
