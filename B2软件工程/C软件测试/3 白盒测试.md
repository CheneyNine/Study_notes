  
# 图论
## 图的定义
节点：有限、非空的节点集合
边
初始节点、终止节点...

***单个节点也算图***；图可以有多个初始节点、终止节点；***但边集合不能是无限的***

路径：一个节点序列，节点与节点之间必须要有边
长度：内部边的数量
Test Path: 一个从初始节点开始到终止节点结束的路径
# 图覆盖准则
用有限空间找出可靠的有限子集，获取可靠的测试结果

## 可达性 reach
- 语法可达Syntactic reach : A path exists in the graph
- 语义可达 Semantic reach : A test exists that can execute that path
现实中会存在语法可达但是语义不可达的内容，这是多余的。

### 覆盖
图覆盖
结构覆盖：仅在顶点和边的图形上定义、源代码、需求说明、设计图
数据流覆盖：要求在图形中标注变量引用


### 测试标准
测试要求 (TR) ： 描述测试路径的属性
测试标准 ： 定义测试要求的规则
满足：  给定标准 C 的测试要求集 TR，当且仅当 TR 中的每一个测试要求，path(T) 中都有一个测试路径满足测试要求 tr 时，测试集 T 在图上满足标准 C。


## 结构化覆盖 （CPC 完全路径覆盖）

### 点覆盖（VC）
当且仅当对于 V 中每个语法上可到达的顶点 v，path(T) 中有一条路径 p 能覆盖 v 时，测试集 T 满足图 G 的顶点覆盖率要求。
TR 包含 G 中的每个可到达顶点。

### 边覆盖（EC）
当且仅当对于 E 中每一条语法上可到达的边 e，path(T) 中都有一条路径 p，使得 p 覆盖了 e 时，测试集 T 才满足图 G 的边覆盖。
TR 包含 G 中的每条可达边。
### 覆盖多条边
边对覆盖：要求覆盖边对
边对覆盖 (EPC)：TR 包含 G 中长度至多为2的每条可达路径。

### nPC
n=0->VC
n=1->EC
n=2->Edge-Pair Coverage
n=∞->Complete Path Coverage (CPC)

***npc 的局限性***：对于单节点，2pc 无法表示
![[Pasted image 20240507215505.png]]

>[!note]
>对于同一个输入，同一个程序，每次执行的 test path 不一定是相同的，当程序涉及到并发执行、外部环境依赖（如文件读写、网络通信）或者随机性时，每次运行的状态结果是不一样的
>
>最简单的，有随机数生成，随机数不一样，根据判断条件，走了执行路径也会不一样。
## 包含
C1 包含 C2，记为 C1≧ C2 :对于任意 T，如果 T 满足 C1，则意味着 T 满足 C2。
***C1≧ C2 并不意味着满足 C1 的 T1 可以检测到满足 C2 的 T2 检测到的任何故障。***
***包含仅仅意味着发现 bug 的概率更高，但发现 bug 需要恰好踩到那个点上***

# 控制流图及其覆盖
代码覆盖率
- 控制流覆盖率
	语句覆盖率 
	分支覆盖率 
	路径覆盖率
覆盖率收集工具: EclEmma

## 控制流图
通常把程序抽象成图 CFG：control flow graph
节点覆盖率：执行每一条语句 
边缘覆盖：执行每个分支

几种语句的控制流图，要绘画！

```c++
if (x < y)
{
   y = 0;
   x = x + 1;
}
else
{
   x = y;
}


if (x < y)
{
   y = 0;
   x = x + 1;
}


if (x < y)
{
   return;
}
print (x);
return;


x = 0;
while (x < y)
{
   y = f (x, y);
   x = x + 1;
}


x = 0;
do
{
   y = f (x, y);
   x = x + 1;
} while (x < y);
println (y)

for (x = 0; x < y; x++)
{
   y = f (x, y);
}


x = 0;
while (x < y)
{
   y = f (x, y);
   if (y == 0)
   {
      break;
   } else if y < 0)
   {
      y = y*2;
      continue;
   }
   x = x + 1;
}
print (y);


read ( c) ;
switch ( c )
{
   case ‘N’:
      y = 25;
      break;
   case ‘Y’:
      y = 50;
      break;
   default:
      y = 0;
      break;
}
print (y);

```

![[Pasted image 20240507224151.png|425]]![[Pasted image 20240507224158.png|400]]![[Pasted image 20240507224527.png|400]]


这两句话解释了不同级别的覆盖率之间的关系。

1. **Branch coverage strictly subsumes statement coverage**:
   - 这意味着分支覆盖严格包含语句覆盖。如果你达到了100%的分支覆盖率，那么你也会自动获得100%的语句覆盖率。这是因为分支覆盖要求每个条件语句的每个分支都被至少执行一次。而每个分支都至少包含一条语句，因此分支覆盖率的达成确保了每个语句都至少被执行一次。

2. **Path coverage strictly subsumes branch coverage**:
   - 这意味着路径覆盖严格包含分支覆盖。如果你达到了100%的路径覆盖率，那么你也会自动获得100%的分支覆盖率。路径覆盖要求测试覆盖软件中的每一条可能路径，而每一条可能的路径都包含通过各种条件语句的所有可能分支组合。因此，达到100%的路径覆盖率确保了所有的分支都被覆盖，从而实现了100%的分支覆盖率。

但是不会只用path-coverage,对于现实世界的程序来说，路径覆盖可能是不可行的

### CFG-based	Coverage有效性
大约65%的所有错误可以在单元测试中发现。
单元测试主要由控制流测试方法主导。
语句和分支测试主导控制流测试。
### CFG-based	Coverage限制
100% coverage of some aspect is never a guarantee of bug-free software

## 覆盖收集：机制
源代码被插装（源代码/二进制文件）
将写入跟踪文件的日志代码插入到每个分支、语句等中。
当插装代码被执行时，覆盖信息将被写入跟踪文件。

# PPC 主路径覆盖
对于包含循环的程序，完全路径覆盖是不可能的

## 简单路径
简单路径：从节点 ni 到节点 nj 的路径是简单路径，条件是除了第一个和最后一个节点可能相同外，没有节点出现超过一次。
无内部循环
循环本身就是一条简单路径
![[Pasted image 20240508143755.png|450]]

## 主路径
不作为任何其他简单路径的子路径出现的简单路径->“最大”的简单路径
![[Pasted image 20240508144217.png|475]]
- **主路径覆盖**（Prime Path Coverage, PPC）：一个简单且有限的覆盖标准，要求同时执行和跳过循环。PPC覆盖所有长度从0开始的路径，包括节点和边覆盖，但不包括每个顶点自身循环的边路径覆盖（EPC）。

## 往返路径
以同一节点为起点和终点的***主要路径***
***SRTC CRTC***
- **简单往返路径：** 对于G中所有可达的，且可以作为往返路径起点和终点的节点，TR包含至少一条往返路径。  
- **完全往返路径：** 对于G中所有可达的节点，TR包含所有的往返路径  
- 如果一个图有自环的话，完全路径覆盖是无用的，因为这会产生无穷的路径，因而产生无穷的测试需求
- 这些标准不包括非往返路径中的节点和边，他不包含边对、边、节点覆盖
![[Pasted image 20240509103614.png]]
SRTC：对于一个节点只要有一条就行
CRTC：一个节点的所有路都要
比如 SRTC 又一个 1241 就可以，但是 CRTC 要包括 1241 还有 1341；
![[Pasted image 20240508152533.png]]


Are some prime paths infeasible?
由于程序的逻辑限制或条件约束，某些路径虽然在控制流图中存在，但在实际情况下无法触发。


# 基本路径覆盖
## 基本路径测试
介于分支覆盖率和全路径覆盖率之间的测试标准
满足分支测试要求的测试，同时也测试所有可用于构建计算机程序任意路径的独立路径。
## 独立路径
只有当系统中的某条路径***包含了其他路径没有包含的顶点或边***时，这条路径才独立于其他路径。
### 线性独立路径
![[Pasted image 20240508162249.png]]
线性独立路径的数量就是该矩阵的秩。
该矩阵的秩正是图的循环复杂度。

## MaCabe 计算公式
Cyclomatic Complexity 环形复杂度：确保每个语句都执行一次的***上界***
CC=E-V+2

>[!bug] 注意
>有多个终点的时候该怎么计算?
>CC=E−N+1
>首尾相连后计算，上面的公式就是通式；或者看分支节点数，仅限于二分支节点，CC=n+1
>https://blog.csdn.net/weixin_42398588/article/details/105622950




### 步骤
生成控制流图
计算循环复杂度
选择一组基本路径
生成基本路径测试

# 数据流覆盖
确保正确计算和使用值
## 概念
- Def：变量值存储的地方
- Use：访问变量值的地方
- def 中的值至少要满足一种、某些或所有可能的用途
- Def & Use 的集合：
- def (n) 或 def (e) ： 由节点 n 或边 e 定义的变量集合 
- use (n) 或 use (e) ： 节点 n 或边 e 使用的变量集合
- DU Pair：一对位置信息，（li，lj），变量 v 在 li 处定义，在 lj 处使用
- Def-Claer：如果从 li 到 lj ***路径中***的任何节点或边都没有给变量 v 赋值，则从 li 到 lj 的路径对变量 v 是Def-Claer（定义清晰的）
- 可达：如果从 li 到 lj 有一条关于 v 并且 Def-Claer的路径，则 v 在 li 处的定义到达了在 lj 处的用途
- DU 路径：从 v 的def到 v 的use中的子路径，并关于v是 def-clear 的
- du (ni, nj, v) the set of du-paths from ni to nj
- du (ni, v) the set of du-paths that start at ni


### 数据流覆盖的准则
ADC：所有定义覆盖
对于每一个 du-path 的集合S，TR 都包含至少 S 中的一条路径
AUC：所有使用覆盖
对于每一个du-path 的集合S，TR 都包含至少 S 中的一条路径
ADUPC：所有 DU 路径覆盖
对于每一个du-path 的集合S，TR 都包含至少 S 中的一条路径

三者中 S 的定义不同
![[Pasted image 20240508191058.png]]
# 强弱准则关系图
待完善！！！
![[Pasted image 20240508194606.png]]


# 事件流图

![[Pasted image 20240508194915.png]]

![[Pasted image 20240508194856.png]]

![[Pasted image 20240508195113.png]]

# 变异测试
## 定义
通过创建程序的多个版本（称为突变体）来引入程序中的错误。 每个突变体包含一个单一的错误。 测试用例将应用于原始程序和突变程序。
目标：使变异程序失败，从而证明测试用例的有效性。 
变异测试是一种***将错误插入程序中以检验测试是否能发现这些错误的方法，从而验证或否定这些测试。*** 
变异测试是一种专注于测试用例充分性的测试技术。 
变异测试应与传统测试技术结合使用，而不是替代它们。
## 变异程序

变异测试需要针对待测程序创建一系列变异程序。 
每个突变体与原始程序的差异仅为一次突变。 
突变是对程序语句进行的单一语法更改。

### 生成变异程序的方法
1. 替换单个操作符
2. 插入新的操作符

## 变异测试流程

- **流程：**
1. 创建突变体。
2. 运行测试用例。
3. 如果测试有错误，就修复；
4. 检查任何未被测试杀死的突变体。
5. 如果所有突变体均被杀死，测试完成；否则，调整测试用例。

## 等效突变体
- **定义：** 存在一些无法杀死的突变体，称为等效突变体。
- 尽管它们在语法上与原始程序不同，但通过测试无法区分。

```
while...  
i++  
if (i==5) break;

while...  
i++  
if (i>=5) break;

```
## 突变评分

- **定义：** 测量测试数据杀死非等效突变体的百分比。
- **公式：**  
    突变得分 = `100 * K / (T - E)`  
    其中：
    - K = 被杀死的突变体数量
    - T = 总突变体数量
    - E = 等效突变体数量
- **充分性：** 测试用例集的突变得分达到100%时，表示测试用例集充分。
## 小结
- 突变是一个单一的语法更改。
- 变异测试用于评估测试的充分性。
# 基于缺陷的测试
## 目标：

通过在代码中人为植入错误（如逻辑错误、操作符错误等）来测试和验证测试***用例的效力***。这种方法不仅帮助*揭示植入的错误*，也用于***评估测试套件***在发现真实错误方面的效果。
## 方法：    

突变是一种常用的基于缺陷的测试方法。
突变是一种单一的语法更改。

## 缺陷类别
- **操作符缺陷类别：**
    
    - 操作符引用缺陷（ORF）
    - 表达式否定缺陷（ENF）
    - 变量否定缺陷（VNF）
    - 关联移位缺陷（ASF）
    
- **操作数缺陷类别：**
    
    - 缺失变量缺陷（MVF）
    - 变量引用缺陷（VRF）
    - 从句连接缺陷（CCF）
    - 从句分离缺陷（CDF）
    - 固定为0缺陷（SA0）
    - 固定为1缺陷（SA1）
## 测试条件
### 定义
测试条件 `E ⊕ E'`
- 测试用例 `t` 如果满足 `E ⊕ E'`，那么能检测到 E 的突变体 E'。
# 逻辑覆盖

## Decision Coverage 决策覆盖

对每个判断的 True 和 False 都执行

## Condition Coverage 条件覆盖

对每个条件的 True 和 False 都执行
条件比判断更多，多个条件组合成一个判断

## 包含关系

DC ≥ SC 决策覆盖包含了语句覆盖 
CC not ≥ SC 条件覆盖不一定包含语句覆盖 
DC not ≥ CC， CC not ≥ DC
决策覆盖和条件覆盖在覆盖范围上各有侧重，没有一方能完全覆盖另一方。

## 多条件覆盖 MCC
多条件覆盖（MCC）反映了每个布尔子表达式的所有可能组合是否发生。
TR 完整多条件覆盖所需的测试用例基本上由***条件的逻辑运算符真值表给出***


## MC / DC
**修改的条件/决策覆盖：**  执行每个条件的独立真假结果。
它确保每个条件在决策中的影响都被单独测试。具体来说，这意味着每个条件变化其值（从真到假或从假到真）时，都应该能够独立地改变整个决策的结果，而不受其他条件的影响。

表达式“MC/DC ≥ C/DC”表示MC/DC在覆盖的程度上***至少等同于条件/决策覆盖，通常是超越后者***，因为它涵盖了C/DC的所有测试要求，同时还添加了额外的独立性要求。

MC/DC 是为包含不进行短路操作的逻辑运算符的语言设计的。在C、C++和Java中的短路逻辑运算符仅在其结果可能影响包含的决策时才评估条件。程序中的决策结构将影响MC/DC。

## 区别总结
DC 最简单，一个 if 语句，执行或不执行，2 次就行
CC 需要根据条件设计，但是只要执行了每个条件的真假就行，不考虑条件对整个 决策的影响
比如 A、B，执行了 非 A 与 B、A 与非 B 就行
MC/DC 确保每个条件至少一次独立地影响整个决策的结果
